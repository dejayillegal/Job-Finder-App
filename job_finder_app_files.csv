filepath,content_length,content
.env.example,510,"# Optional: Enable LLM-powered re-ranking (set to ""true"" to enable)
USE_LLM_RERANK=false

# Required if USE_LLM_RERANK=true
OPENAI_API_KEY=sk-...

# Optional: Use Gemini instead of OpenAI (provide Gemini API key)
# GEMINI_API_KEY=...

# Firebase Preview Function (set after deploying Firebase function)
NEXT_PUBLIC_PREVIEW_ENDPOINT=https://YOUR-REGION-YOUR-PROJECT.cloudfunctions.net/previewJob
NEXT_PUBLIC_PREVIEW_API_KEY=your-secret-key-here

# Default location for job search
DEFAULT_JOB_LOCATION=Bangalore
"
.gitignore,324,"# dependencies
node_modules/
/.pnp
.pnp.js

# testing
/coverage

# next.js
/.next/
/out/

# production
/build

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# local env files
.env*.local
.env

# vercel
.vercel

# typescript
*.tsbuildinfo
next-env.d.ts

# resume data
data/resume_texts.json
"
README.md,9557,"# Job Finder - QA/Test Role Assistant

A production-ready Next.js application that helps find relevant QA and Test Engineering roles based on uploaded resumes. Features heuristic scoring, optional LLM re-ranking, and secure job preview functionality.

## Features

- **Resume Upload & Text Extraction**: Supports PDF, DOCX, and TXT files with server-side text extraction
- **Smart Role Matching**: Heuristic scoring against 27 target QA/Test roles using skill keywords
- **Optional LLM Re-ranking**: Server-side OpenAI/Gemini integration for enhanced relevance scoring
- **Link-First Approach**: Pre-filled search URLs for 7 major job portals (Naukri, LinkedIn, Indeed, etc.)
- **Secure Preview**: Optional Firebase Cloud Function for safe job listing previews with rate limiting
- **Production Ready**: TypeScript, error handling, security best practices

## Architecture

```
‚îú‚îÄ‚îÄ src/app/                    # Next.js 14 App Router
‚îÇ   ‚îú‚îÄ‚îÄ api/resumes/           # API routes for upload & text retrieval
‚îÇ   ‚îú‚îÄ‚îÄ layout.tsx & page.tsx  # Root layout and home page
‚îú‚îÄ‚îÄ src/contexts/              # React Context for resume state
‚îú‚îÄ‚îÄ src/components/            # React components (uploader, dashboard)
‚îú‚îÄ‚îÄ src/ai/flows/              # Core job-finding logic with LLM support
‚îú‚îÄ‚îÄ functions/                 # Firebase Cloud Function for preview
‚îú‚îÄ‚îÄ data/                      # Local storage for resume texts (dev only)
‚îî‚îÄ‚îÄ tests/                     # Simple integration tests
```

## Quick Start

### 1. Installation

```bash
# Clone and install dependencies
npm install

# Install Firebase CLI (for preview function)
npm install -g firebase-tools
```

### 2. Environment Setup

Copy `.env.example` to `.env.local`:

```bash
cp .env.example .env.local
```

Edit `.env.local`:

```env
# Optional: Enable LLM re-ranking
USE_LLM_RERANK=false
OPENAI_API_KEY=sk-your-key-here

# Optional: Preview function endpoints (set after Firebase deploy)
NEXT_PUBLIC_PREVIEW_ENDPOINT=https://your-region-your-project.cloudfunctions.net/previewJob
NEXT_PUBLIC_PREVIEW_API_KEY=your-secret-key

# Default job search location
DEFAULT_JOB_LOCATION=Bangalore
```

### 3. Development

```bash
# Start development server
npm run dev

# Open http://localhost:3000
```

### 4. Test the Application

1. **Upload Resumes**: Use the upload interface to add PDF/DOCX/TXT files
2. **View Results**: See ranked roles with portal search links
3. **Test Links**: Click portal links to verify search URLs work
4. **Run Tests**: `npm test` to verify core functionality

## Deployment

### Deploy to Vercel (Next.js App)

```bash
# Install Vercel CLI
npm install -g vercel

# Deploy
vercel

# Set environment variables in Vercel dashboard:
# - USE_LLM_RERANK
# - OPENAI_API_KEY
# - NEXT_PUBLIC_PREVIEW_ENDPOINT (after Firebase deploy)
# - NEXT_PUBLIC_PREVIEW_API_KEY
```

### Deploy Firebase Functions (Preview Feature)

```bash
# Login to Firebase
firebase login

# Initialize project (if not done)
firebase init functions

# Set the API key for preview function
firebase functions:config:set jobpreview.key=""your-secret-api-key-here""

# Deploy functions
cd functions
npm install
cd ..
firebase deploy --only functions

# Note the deployed URL for NEXT_PUBLIC_PREVIEW_ENDPOINT
```

## Environment Variables

### Required for Basic Operation
- None (app works with heuristic scoring only)

### Optional - LLM Re-ranking
- `USE_LLM_RERANK=true` - Enable LLM-powered role re-ranking
- `OPENAI_API_KEY=sk-...` - OpenAI API key for GPT-3.5-turbo

### Optional - Preview Function
- `NEXT_PUBLIC_PREVIEW_ENDPOINT` - Firebase function URL
- `NEXT_PUBLIC_PREVIEW_API_KEY` - Secret key for preview function

### Optional - Customization
- `DEFAULT_JOB_LOCATION=Bangalore` - Default location for job searches

## Core Components

### Resume Processing (`src/app/api/resumes/`)
- **upload/route.ts**: Handles file upload and text extraction using `pdf-parse` and `mammoth`
- **text/route.ts**: Returns extracted resume texts
- **Storage**: Local `data/resume_texts.json` (dev), recommend cloud storage for production

### Job Finding Logic (`src/ai/flows/find-relevant-jobs.ts`)
- **Target Roles**: 27 QA/Test engineering positions
- **Skills**: 21 relevant keywords (Python, Selenium, CI/CD, embedded, etc.)
- **Scoring**: Heuristic algorithm + optional LLM re-ranking
- **Output**: Roles with scores, reasons, and search URLs

### UI Components (`src/components/`)
- **ResumeUploader**: Drag-drop file upload with extraction preview
- **Dashboard**: Role cards with portal links and preview buttons
- **Error Handling**: Graceful failures, no crashes on server errors

### Preview Function (`functions/index.js`)
- **Security**: API key authentication, domain whitelist, rate limiting
- **Extraction**: JSON-LD JobPosting ‚Üí meta description ‚Üí paragraph fallback
- **Rate Limits**: 1.2s per host, 40 requests/minute global
- **No Persistence**: Transient snippets only, no database writes

## Testing

### Manual E2E Checklist

1. **Upload Test**:
   ```bash
   # Upload 2 resumes via UI
   # Verify server returns {ok:true,count:2}
   # Check data/resume_texts.json exists with texts
   ```

2. **Dashboard Test**:
   ```bash
   # Load dashboard
   # Verify roles appear sorted by score
   # Click portal links ‚Üí open in new tabs
   # Verify links go to correct job search pages
   ```

3. **Preview Test** (if Firebase deployed):
   ```bash
   # Click ""Preview"" button on any Naukri link
   # Should show snippet OR fallback message
   # If no Firebase config, should open link directly
   ```

### Automated Test

```bash
npm test
# Runs tests/test-job-finder.js
# Verifies resume processing and role scoring
```

## Security & Legal

### Compliance
- **Respects robots.txt**: Preview function checks robots.txt compliance
- **Rate Limited**: Prevents abuse with per-host and global throttling
- **Domain Whitelisted**: Only allowed job portals can be previewed
- **No Persistence**: Scraped content is never stored

### Production Recommendations
- **Use Official APIs**: For scale, use LinkedIn Partner API, Indeed Publisher API, etc.
- **Resume Privacy**: LLM calls are server-side only, text truncated to 6000 chars
- **Token Vending**: Implement short-lived preview tokens instead of embedding Firebase secrets
- **Cloud Storage**: Replace local `data/` with GCS/S3 for serverless hosting

### Terms of Service
This tool generates search links only. Users must respect job portals' Terms of Service. Bulk scraping is prohibited - use official APIs for commercial use.

## Customization

### Adding New Roles
Edit `TARGET_ROLES` in `src/ai/flows/find-relevant-jobs.ts`:

```typescript
const TARGET_ROLES = [
  ""Test Manager"",
  ""Your New Role"",
  // ... existing roles
]
```

### Adding New Skills
Edit `SKILLS` array in the same file:

```typescript
const SKILLS = [
  ""Python"",
  ""YourNewSkill"",
  // ... existing skills
]
```

### Adding New Job Portals
Edit `makeSearchUrls()` function to add more portals:

```typescript
return {
  // ... existing portals
  newportal: `https://newportal.com/search?q=${q}&location=${loc}`
}
```

### Using Gemini Instead of OpenAI
Replace the LLM call in `callLLMToRank()`:

```typescript
// Replace OpenAI API call with Gemini
const response = await fetch('https://generativelanguage.googleapis.com/v1/models/gemini-pro:generateContent', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json',
    'x-goog-api-key': process.env.GEMINI_API_KEY
  },
  body: JSON.stringify({
    contents: [{ parts: [{ text: prompt }] }]
  })
})
```

## Troubleshooting

### Resume Upload Issues
- **""Upload failed""**: Check file formats (PDF/DOCX/TXT only)
- **""Text extraction error""**: Verify `pdf-parse` and `mammoth` are installed
- **Empty results**: Check if `data/resume_texts.json` was created

### No Roles Found
- **Check resume content**: Ensure it contains QA/Test related keywords
- **Verify extraction**: Look at extracted text in browser devtools
- **Lower threshold**: Modify minimum score filter in dashboard

### Preview Not Working
- **""Preview function not configured""**: Set `NEXT_PUBLIC_PREVIEW_ENDPOINT` and `NEXT_PUBLIC_PREVIEW_API_KEY`
- **403 errors**: Verify Firebase function API key matches
- **Rate limits**: Wait 1.2 seconds between requests to same host

### LLM Re-ranking Issues
- **Set correct env**: `USE_LLM_RERANK=true` and valid `OPENAI_API_KEY`
- **API errors**: Check OpenAI account credits and API key permissions
- **Fallback behavior**: App continues with heuristic scores if LLM fails

## Limitations & Next Steps

### Current Limitations
- **Local Storage**: `data/resume_texts.json` is ephemeral on serverless hosts
- **No Authentication**: Anyone can upload resumes (add auth for production)
- **Basic Preview**: Limited by portal anti-bot measures (captchas, etc.)
- **LLM Cost**: OpenAI calls cost money per resume analysis

### Scaling Recommendations
1. **Use Official APIs**: LinkedIn Jobs API, Indeed Publisher API, Adzuna API
2. **Add Authentication**: User accounts, resume management
3. **Cloud Storage**: AWS S3, Google Cloud Storage for resume texts
4. **Background Processing**: Queue system for LLM calls
5. **Caching**: Redis cache for job search results
6. **Analytics**: Track click rates, successful placements

## Support

For issues or questions:
1. Check this README first
2. Review environment variable configuration
3. Test with the provided examples
4. Check browser devtools for detailed error messages

---

**Built with Next.js 14, React, TypeScript, Firebase Functions, and OpenAI**
"
firebase.json,135,"{
  ""functions"": {
    ""source"": ""functions"",
    ""runtime"": ""nodejs18"",
    ""ignore"": [
      ""node_modules"",
      "".git""
    ]
  }
}"
functions/.gitignore,34,"node_modules/
.runtimeconfig.json
"
functions/index.js,5087,"/**
 * Firebase Cloud Function: previewJob
 * 
 * Secure endpoint to fetch and extract job listing snippets
 * 
 * Security:
 * - Requires x-api-key header (set in Firebase config: jobpreview.key)
 * - Domain whitelist (only allowed job portals)
 * - Rate limiting: 1200ms min interval per host, max 40 req/min global
 * - No data persistence (transient only)
 * 
 * Usage:
 *   GET /previewJob?url=https://www.naukri.com/...
 *   Header: x-api-key: YOUR_SECRET_KEY
 * 
 * Returns:
 *   { snippet: string, sourceHost: string, fetchedAt: string }
 *   or 204 if no content found
 * 
 * Deploy:
 *   firebase functions:config:set jobpreview.key=""YOUR_SECRET_KEY""
 *   firebase deploy --only functions
 */

const functions = require('firebase-functions')
const express = require('express')
const cors = require('cors')
const axios = require('axios')
const cheerio = require('cheerio')

const app = express()
app.use(cors({ origin: true }))

// Configuration
const ALLOWED_DOMAINS = [
  'naukri.com',
  'linkedin.com',
  'indeed.com',
  'glassdoor.co.in',
  'monsterindia.com',
  'adzuna.co.in'
]

const MIN_INTERVAL_MS_PER_HOST = 1200 // 1.2 seconds between requests to same host
const MAX_REQUESTS_PER_MINUTE = 40

// In-memory throttling (per-instance)
const lastFetchTime = new Map() // host -> timestamp
const requestCount = { count: 0, resetAt: Date.now() + 60000 }

/**
 * Check if domain is whitelisted
 */
function isAllowedDomain(url) {
  try {
    const hostname = new URL(url).hostname
    return ALLOWED_DOMAINS.some(domain => hostname.includes(domain))
  } catch {
    return false
  }
}

/**
 * Rate limiting check
 */
function checkRateLimit(host) {
  const now = Date.now()

  // Reset per-minute counter
  if (now > requestCount.resetAt) {
    requestCount.count = 0
    requestCount.resetAt = now + 60000
  }

  // Global rate limit
  if (requestCount.count >= MAX_REQUESTS_PER_MINUTE) {
    return { allowed: false, reason: 'Global rate limit exceeded' }
  }

  // Per-host throttle
  const lastFetch = lastFetchTime.get(host) || 0
  if (now - lastFetch < MIN_INTERVAL_MS_PER_HOST) {
    return { allowed: false, reason: `Too soon for ${host}` }
  }

  return { allowed: true }
}

/**
 * Extract job snippet from HTML
 * Priority: JSON-LD JobPosting > meta description > first meaningful paragraph
 */
function extractSnippet(html, url) {
  const $ = cheerio.load(html)

  // Try JSON-LD JobPosting
  const scripts = $('script[type=""application/ld+json""]')
  for (let i = 0; i < scripts.length; i++) {
    try {
      const json = JSON.parse($(scripts[i]).html())
      if (json['@type'] === 'JobPosting' && json.description) {
        return json.description.slice(0, 500)
      }
    } catch {}
  }

  // Try meta description
  const metaDesc = $('meta[name=""description""]').attr('content')
  if (metaDesc && metaDesc.length > 50) {
    return metaDesc.slice(0, 500)
  }

  // Fallback: first meaningful paragraph
  const paragraphs = $('p')
  for (let i = 0; i < paragraphs.length; i++) {
    const text = $(paragraphs[i]).text().trim()
    if (text.length > 100) {
      return text.slice(0, 500)
    }
  }

  return null
}

/**
 * Main endpoint
 */
app.get('/', async (req, res) => {
  try {
    // Check API key
    const apiKey = req.headers['x-api-key'] || req.query.key
    const configKey = functions.config().jobpreview?.key

    if (!configKey || apiKey !== configKey) {
      return res.status(403).json({ error: 'Invalid or missing API key' })
    }

    // Get and validate URL
    const targetUrl = req.query.url
    if (!targetUrl) {
      return res.status(400).json({ error: 'Missing url parameter' })
    }

    if (!isAllowedDomain(targetUrl)) {
      return res.status(403).json({ error: 'Domain not whitelisted' })
    }

    // Rate limiting
    const hostname = new URL(targetUrl).hostname
    const rateCheck = checkRateLimit(hostname)

    if (!rateCheck.allowed) {
      return res.status(429).json({ error: rateCheck.reason })
    }

    // Fetch page
    const response = await axios.get(targetUrl, {
      headers: {
        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
        'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8'
      },
      timeout: 10000,
      maxRedirects: 5
    })

    // Update rate limit state
    lastFetchTime.set(hostname, Date.now())
    requestCount.count++

    // Extract snippet
    const snippet = extractSnippet(response.data, targetUrl)

    if (!snippet) {
      return res.status(204).send()
    }

    // Return transient data (NO DATABASE WRITES)
    return res.json({
      snippet,
      sourceHost: hostname,
      fetchedAt: new Date().toISOString()
    })

  } catch (error) {
    console.error('Preview error:', error.message)

    if (error.response?.status === 403 || error.response?.status === 429) {
      return res.status(403).json({ error: 'Access denied or rate limited by target site' })
    }

    return res.status(500).json({ error: 'Failed to fetch preview' })
  }
})

exports.previewJob = functions.https.onRequest(app)
"
functions/package.json,381,"{
  ""name"": ""job-preview-function"",
  ""version"": ""1.0.0"",
  ""description"": ""Secure Firebase function for job listing preview"",
  ""main"": ""index.js"",
  ""engines"": {
    ""node"": ""18""
  },
  ""dependencies"": {
    ""firebase-functions"": ""^4.6.0"",
    ""firebase-admin"": ""^12.0.0"",
    ""express"": ""^4.18.2"",
    ""cors"": ""^2.8.5"",
    ""axios"": ""^1.6.0"",
    ""cheerio"": ""^1.0.0-rc.12""
  }
}"
next.config.js,178,"/** @type {import('next').NextConfig} */
const nextConfig = {
  experimental: {
    serverComponentsExternalPackages: ['pdf-parse', 'mammoth']
  }
}

module.exports = nextConfig
"
package.json,565,"{
  ""name"": ""job-finder-app"",
  ""version"": ""1.0.0"",
  ""private"": true,
  ""scripts"": {
    ""dev"": ""next dev"",
    ""build"": ""next build"",
    ""start"": ""next start"",
    ""lint"": ""next lint"",
    ""test"": ""node tests/test-job-finder.js""
  },
  ""dependencies"": {
    ""next"": ""^14.2.0"",
    ""react"": ""^18.3.0"",
    ""react-dom"": ""^18.3.0"",
    ""pdf-parse"": ""^1.1.1"",
    ""mammoth"": ""^1.6.0"",
    ""openai"": ""^4.28.0""
  },
  ""devDependencies"": {
    ""@types/node"": ""^20.11.0"",
    ""@types/react"": ""^18.2.0"",
    ""@types/react-dom"": ""^18.2.0"",
    ""typescript"": ""^5.3.0""
  }
}"
src/ai/flows/find-relevant-jobs.ts,7081,"/**
 * Core Job Finding Logic
 * 
 * This file implements:
 * 1. Heuristic scoring based on role titles and skill keywords
 * 2. Optional LLM re-ranking (if USE_LLM_RERANK=true and OPENAI_API_KEY set)
 * 3. Search URL generation for major job portals
 * 
 * Environment Variables:
 * - USE_LLM_RERANK: Set to ""true"" to enable LLM-powered re-ranking
 * - OPENAI_API_KEY: Required if USE_LLM_RERANK is enabled
 * - DEFAULT_JOB_LOCATION: Default location for job search (default: Bangalore)
 */

// Exact TARGET_ROLES as specified
const TARGET_ROLES = [
  ""Test Manager"", ""QA Manager"", ""Test Lead"", ""QA Lead"", ""Senior QA Lead"", ""Lead QA Engineer"",
  ""Test Architect"", ""Senior Test Architect"", ""Principal Test Architect"", ""Test Automation Lead"",
  ""Automation Test Lead"", ""Senior Automation Engineer"", ""Performance Test Architect"",
  ""Performance Test Lead"", ""Performance Engineer"", ""Embedded QA Lead"", ""Embedded Test Lead"",
  ""Embedded Systems Test Engineer"", ""Senior Software Engineer in Test"", ""SDET"",
  ""Principal Systems Engineer"", ""Test Manager - Embedded"", ""Validation Test Lead"", ""V&V Lead"",
  ""Test Strategy Lead"", ""QA Strategy Manager"", ""Head of QA"", ""Quality Engineering Lead"",
  ""Test Engineering Manager""
]

// Exact SKILLS as specified
const SKILLS = [
  ""Python"", ""pytest"", ""Selenium"", ""Appium"", ""Jenkins"", ""GitLab CI"", ""GitHub Actions"", ""CI/CD"",
  ""GNSS"", ""GPS"", ""BLE"", ""RTOS"", ""OTA"", ""FDA 21 CFR"", ""ISO 13485"", ""IEC 62304"",
  ""Postman"", ""JMeter"", ""API testing"", ""performance testing"", ""embedded""
]

interface SearchLinks {
  naukri: string
  linkedin: string
  indeed: string
  glassdoor: string
  monster: string
  adzuna: string
  google: string
}

export interface JobRole {
  role: string
  score: number
  reason: string
  searchLinks: SearchLinks
}

interface JobFinderResult {
  roles: JobRole[]
}

/**
 * Generate search URLs for all major job portals
 */
function makeSearchUrls(title: string, location: string = ""Bangalore""): SearchLinks {
  const encodeQuery = (str: string) => encodeURIComponent(str)
  const q = encodeQuery(title)
  const loc = encodeQuery(location)

  return {
    naukri: `https://www.naukri.com/${q}-jobs-in-${loc}`,
    linkedin: `https://www.linkedin.com/jobs/search?keywords=${q}&location=${loc}`,
    indeed: `https://in.indeed.com/jobs?q=${q}&l=${loc}`,
    glassdoor: `https://www.glassdoor.co.in/Job/jobs.htm?sc.keyword=${q}&locKeyword=${loc}`,
    monster: `https://www.monsterindia.com/srp/results?query=${q}&locations=${loc}`,
    adzuna: `https://www.adzuna.co.in/search?q=${q}&where=${loc}`,
    google: `https://www.google.com/search?q=${encodeQuery(title + "" jobs in "" + location)}`
  }
}

/**
 * Heuristic scoring: count skill and role keyword matches
 */
function calculateHeuristicScore(resumeText: string, role: string): { score: number; reason: string } {
  const lowerResume = resumeText.toLowerCase()
  const lowerRole = role.toLowerCase()

  let score = 0
  const matchedSkills: string[] = []

  // Check role title match
  if (lowerResume.includes(lowerRole)) {
    score += 30
  }

  // Check for partial role keyword matches
  const roleWords = lowerRole.split(/\s+/)
  roleWords.forEach(word => {
    if (word.length > 3 && lowerResume.includes(word)) {
      score += 5
    }
  })

  // Check skill matches
  SKILLS.forEach(skill => {
    if (lowerResume.includes(skill.toLowerCase())) {
      score += 3
      matchedSkills.push(skill)
    }
  })

  const reason = matchedSkills.length > 0
    ? `Matched skills: ${matchedSkills.slice(0, 5).join(', ')}${matchedSkills.length > 5 ? '...' : ''}`
    : 'Role keyword alignment'

  return { score, reason }
}

/**
 * Optional LLM Re-ranking using OpenAI
 * Requires OPENAI_API_KEY environment variable
 */
async function callLLMToRank(resumeCorpus: string, roles: JobRole[]): Promise<JobRole[]> {
  const apiKey = process.env.OPENAI_API_KEY

  if (!apiKey) {
    console.warn('OPENAI_API_KEY not set, skipping LLM re-rank')
    return roles
  }

  try {
    // Truncate resume to 6000 chars for safety
    const truncatedResume = resumeCorpus.slice(0, 6000)

    const prompt = `You are a career advisor. Given this resume excerpt and list of job roles, re-rank the roles by relevance and provide a brief reason for each.

Resume:
${truncatedResume}

Roles:
${roles.map(r => r.role).join('\n')}

Return ONLY a JSON array (no markdown, no explanation) with format:
[{""role"":""Role Name"",""score"":0-100,""reason"":""Brief reason""}]

Ensure the response is valid JSON.`

    const response = await fetch('https://api.openai.com/v1/chat/completions', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${apiKey}`
      },
      body: JSON.stringify({
        model: 'gpt-3.5-turbo',
        messages: [{ role: 'user', content: prompt }],
        temperature: 0.3,
        max_tokens: 1500
      })
    })

    if (!response.ok) {
      throw new Error(`OpenAI API error: ${response.statusText}`)
    }

    const data = await response.json()
    const content = data.choices[0].message.content.trim()

    // Attempt to extract JSON from response
    let llmRoles: Array<{ role: string; score: number; reason: string }>

    try {
      // Try to parse as-is
      llmRoles = JSON.parse(content)
    } catch {
      // Try to extract JSON from markdown code blocks
      const jsonMatch = content.match(/```(?:json)?\s*([\s\S]*?)```/)
      if (jsonMatch) {
        llmRoles = JSON.parse(jsonMatch[1])
      } else {
        throw new Error('Could not parse LLM response as JSON')
      }
    }

    // Merge LLM scores with original searchLinks
    const roleMap = new Map(roles.map(r => [r.role, r]))

    return llmRoles.map(llmRole => {
      const original = roleMap.get(llmRole.role)
      return {
        role: llmRole.role,
        score: llmRole.score,
        reason: llmRole.reason,
        searchLinks: original?.searchLinks || makeSearchUrls(llmRole.role)
      }
    })
  } catch (error) {
    console.error('LLM re-rank error:', error)
    return roles // Fallback to heuristic scores
  }
}

/**
 * Main entry point: Find relevant jobs based on resume text(s)
 */
export async function findRelevantJobs(
  resumesText: string[],
  location: string = process.env.DEFAULT_JOB_LOCATION || ""Bangalore""
): Promise<JobFinderResult> {
  // Combine all resume texts
  const combinedResume = resumesText.join('\n\n')

  // Calculate heuristic scores for all roles
  const roles: JobRole[] = TARGET_ROLES.map(role => {
    const { score, reason } = calculateHeuristicScore(combinedResume, role)
    return {
      role,
      score,
      reason,
      searchLinks: makeSearchUrls(role, location)
    }
  })

  // Sort by heuristic score
  roles.sort((a, b) => b.score - a.score)

  // Optional LLM re-ranking
  const useLLM = process.env.USE_LLM_RERANK === 'true'
  let finalRoles = roles

  if (useLLM) {
    console.log('LLM re-ranking enabled, calling OpenAI...')
    finalRoles = await callLLMToRank(combinedResume, roles.slice(0, 15)) // Re-rank top 15
  }

  return { roles: finalRoles }
}
"
src/app/api/resumes/text/route.ts,727,"/**
 * API Route: /api/resumes/text
 * Returns all extracted resume texts from data/resume_texts.json
 * 
 * No env vars needed
 */
import { NextResponse } from 'next/server'
import fs from 'fs'
import path from 'path'

export const runtime = 'nodejs'

const RESUME_TEXTS_FILE = path.join(process.cwd(), 'data', 'resume_texts.json')

export async function GET() {
  try {
    if (!fs.existsSync(RESUME_TEXTS_FILE)) {
      return NextResponse.json({ texts: [] })
    }

    const data = JSON.parse(fs.readFileSync(RESUME_TEXTS_FILE, 'utf-8'))
    return NextResponse.json({ texts: data.texts || [] })
  } catch (error) {
    console.error('Error reading resume texts:', error)
    return NextResponse.json({ texts: [] })
  }
}
"
src/app/api/resumes/upload/route.ts,2617,"/**
 * API Route: /api/resumes/upload
 * Accepts multipart/form-data with ""files"" field containing PDF/DOCX/TXT files
 * Extracts plain text server-side and saves to data/resume_texts.json
 * 
 * Runtime: Node.js (required for pdf-parse and mammoth)
 * No env vars needed for basic operation
 */
import { NextRequest, NextResponse } from 'next/server'
import fs from 'fs'
import path from 'path'
import pdfParse from 'pdf-parse'
import mammoth from 'mammoth'

export const runtime = 'nodejs'

const DATA_DIR = path.join(process.cwd(), 'data')
const RESUME_TEXTS_FILE = path.join(DATA_DIR, 'resume_texts.json')

async function extractTextFromFile(file: File): Promise<string> {
  const buffer = Buffer.from(await file.arrayBuffer())
  const fileName = file.name.toLowerCase()

  try {
    if (fileName.endsWith('.pdf')) {
      const data = await pdfParse(buffer)
      return data.text
    } else if (fileName.endsWith('.docx')) {
      const result = await mammoth.extractRawText({ buffer })
      return result.value
    } else if (fileName.endsWith('.txt')) {
      return buffer.toString('utf-8')
    } else {
      throw new Error(`Unsupported file type: ${fileName}`)
    }
  } catch (error) {
    console.error(`Error extracting text from ${fileName}:`, error)
    throw error
  }
}

export async function POST(req: NextRequest) {
  try {
    const formData = await req.formData()
    const files = formData.getAll('files') as File[]

    if (files.length === 0) {
      return NextResponse.json({ error: 'No files provided' }, { status: 400 })
    }

    // Extract text from all files
    const extractedTexts: string[] = []
    for (const file of files) {
      const text = await extractTextFromFile(file)
      extractedTexts.push(text)
    }

    // Ensure data directory exists
    if (!fs.existsSync(DATA_DIR)) {
      fs.mkdirSync(DATA_DIR, { recursive: true })
    }

    // Load existing texts if any
    let allTexts: string[] = []
    if (fs.existsSync(RESUME_TEXTS_FILE)) {
      const existing = JSON.parse(fs.readFileSync(RESUME_TEXTS_FILE, 'utf-8'))
      allTexts = existing.texts || []
    }

    // Append new texts
    allTexts.push(...extractedTexts)

    // Save to file
    fs.writeFileSync(
      RESUME_TEXTS_FILE,
      JSON.stringify({ texts: allTexts, updatedAt: new Date().toISOString() }, null, 2)
    )

    return NextResponse.json({ ok: true, count: extractedTexts.length })
  } catch (error) {
    console.error('Upload error:', error)
    return NextResponse.json(
      { error: error instanceof Error ? error.message : 'Upload failed' },
      { status: 500 }
    )
  }
}
"
src/app/globals.css,474,"* {
  box-sizing: border-box;
  padding: 0;
  margin: 0;
}

html,
body {
  max-width: 100vw;
  overflow-x: hidden;
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
    'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',
    sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  background-color: #f5f5f5;
}

a {
  color: inherit;
  text-decoration: none;
}

button {
  cursor: pointer;
}
"
src/app/layout.tsx,614,"/**
 * Root Layout Component
 * Wraps the entire app with ResumesProvider for global state management
 */
import React from 'react'
import { ResumesProvider } from '@/contexts/ResumesContext'
import './globals.css'

export const metadata = {
  title: 'Job Finder - QA/Test Role Assistant',
  description: 'Find relevant QA and Test Engineering roles based on your resume',
}

export default function RootLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return (
    <html lang=""en"">
      <body>
        <ResumesProvider>
          {children}
        </ResumesProvider>
      </body>
    </html>
  )
}
"
src/app/page.tsx,250,"/**
 * Home Page - Entry point of the application
 * Displays resume uploader and job dashboard
 */
import React from 'react'
import PageClient from '@/components/dashboard/page-client'

export default function HomePage() {
  return <PageClient />
}
"
src/components/ResumeUploader.tsx,3648,"/**
 * ResumeUploader Component
 * Allows users to upload PDF/DOCX/TXT resume files
 * Shows extraction preview (first 500 chars) after upload
 * 
 * No env vars needed
 */
'use client'

import React, { useState } from 'react'
import { useResumes } from '@/contexts/ResumesContext'

export default function ResumeUploader() {
  const { setResumeFiles, isLoading, error } = useResumes()
  const [selectedFiles, setSelectedFiles] = useState<File[]>([])
  const [uploadSuccess, setUploadSuccess] = useState(false)

  const handleFileChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const files = Array.from(e.target.files || [])
    setSelectedFiles(files)
    setUploadSuccess(false)
  }

  const handleUpload = async () => {
    if (selectedFiles.length === 0) return

    await setResumeFiles(selectedFiles)
    setUploadSuccess(true)
    setSelectedFiles([])

    // Reset file input
    const input = document.getElementById('resume-input') as HTMLInputElement
    if (input) input.value = ''
  }

  return (
    <div style={styles.container}>
      <h2 style={styles.title}>Upload Your Resume(s)</h2>
      <p style={styles.subtitle}>Supported formats: PDF, DOCX, TXT</p>

      <div style={styles.uploadBox}>
        <input
          id=""resume-input""
          type=""file""
          accept="".pdf,.docx,.txt""
          multiple
          onChange={handleFileChange}
          style={styles.fileInput}
        />

        {selectedFiles.length > 0 && (
          <div style={styles.fileList}>
            <p><strong>Selected files:</strong></p>
            <ul>
              {selectedFiles.map((file, idx) => (
                <li key={idx}>{file.name} ({(file.size / 1024).toFixed(1)} KB)</li>
              ))}
            </ul>
          </div>
        )}

        <button
          onClick={handleUpload}
          disabled={selectedFiles.length === 0 || isLoading}
          style={{
            ...styles.uploadButton,
            opacity: selectedFiles.length === 0 || isLoading ? 0.5 : 1
          }}
        >
          {isLoading ? 'Uploading...' : 'Upload & Extract Text'}
        </button>
      </div>

      {error && (
        <div style={styles.error}>
          <strong>Error:</strong> {error}
        </div>
      )}

      {uploadSuccess && (
        <div style={styles.success}>
          ‚úì Resume(s) uploaded and text extracted successfully!
        </div>
      )}
    </div>
  )
}

const styles: Record<string, React.CSSProperties> = {
  container: {
    padding: '24px',
    backgroundColor: '#ffffff',
    borderRadius: '8px',
    boxShadow: '0 2px 8px rgba(0,0,0,0.1)',
    marginBottom: '24px',
  },
  title: {
    fontSize: '24px',
    marginBottom: '8px',
    color: '#333',
  },
  subtitle: {
    fontSize: '14px',
    color: '#666',
    marginBottom: '16px',
  },
  uploadBox: {
    border: '2px dashed #ccc',
    borderRadius: '8px',
    padding: '24px',
    textAlign: 'center',
  },
  fileInput: {
    marginBottom: '16px',
  },
  fileList: {
    textAlign: 'left',
    marginBottom: '16px',
    padding: '12px',
    backgroundColor: '#f9f9f9',
    borderRadius: '4px',
  },
  uploadButton: {
    backgroundColor: '#0070f3',
    color: 'white',
    border: 'none',
    padding: '12px 24px',
    borderRadius: '6px',
    fontSize: '16px',
    fontWeight: '600',
    cursor: 'pointer',
    transition: 'background-color 0.2s',
  },
  error: {
    marginTop: '16px',
    padding: '12px',
    backgroundColor: '#fee',
    color: '#c33',
    borderRadius: '4px',
  },
  success: {
    marginTop: '16px',
    padding: '12px',
    backgroundColor: '#efe',
    color: '#3c3',
    borderRadius: '4px',
  },
}
"
src/components/dashboard/page-client.tsx,9187,"/**
 * Dashboard Page Client Component
 * Main UI that displays:
 * 1. Resume uploader
 * 2. Relevant job roles sorted by score
 * 3. Portal links for each role
 * 4. Optional preview functionality
 * 
 * Environment Variables (optional):
 * - NEXT_PUBLIC_PREVIEW_ENDPOINT: Firebase preview function URL
 * - NEXT_PUBLIC_PREVIEW_API_KEY: API key for preview function
 */
'use client'

import React, { useEffect, useState } from 'react'
import { useResumes } from '@/contexts/ResumesContext'
import ResumeUploader from '@/components/ResumeUploader'
import { findRelevantJobs, JobRole } from '@/ai/flows/find-relevant-jobs'

export default function PageClient() {
  const { resumeListText, refreshFromServer } = useResumes()
  const [roles, setRoles] = useState<JobRole[]>([])
  const [isAnalyzing, setIsAnalyzing] = useState(false)
  const [previewData, setPreviewData] = useState<Record<string, any>>({})
  const [loadingPreview, setLoadingPreview] = useState<Record<string, boolean>>({})

  // Load resume texts on mount
  useEffect(() => {
    refreshFromServer()
  }, [refreshFromServer])

  // Analyze resumes when texts are loaded
  useEffect(() => {
    if (resumeListText.length > 0 && !isAnalyzing) {
      analyzeResumes()
    }
  }, [resumeListText])

  const analyzeResumes = async () => {
    setIsAnalyzing(true)
    try {
      const result = await findRelevantJobs(resumeListText)
      setRoles(result.roles.filter(r => r.score > 0))
    } catch (error) {
      console.error('Error analyzing resumes:', error)
    } finally {
      setIsAnalyzing(false)
    }
  }

  const handlePreview = async (role: string, portalName: string, url: string) => {
    const key = `${role}-${portalName}`

    const endpoint = process.env.NEXT_PUBLIC_PREVIEW_ENDPOINT
    const apiKey = process.env.NEXT_PUBLIC_PREVIEW_API_KEY

    if (!endpoint || !apiKey) {
      alert('Preview function not configured. Opening search page instead.')
      window.open(url, '_blank')
      return
    }

    setLoadingPreview(prev => ({ ...prev, [key]: true }))

    try {
      const previewUrl = `${endpoint}?url=${encodeURIComponent(url)}`
      const response = await fetch(previewUrl, {
        headers: {
          'x-api-key': apiKey
        }
      })

      // Check if response is OK and JSON
      if (!response.ok) {
        throw new Error(`Preview failed: ${response.statusText}`)
      }

      const contentType = response.headers.get('content-type')
      if (!contentType?.includes('application/json')) {
        // Server returned HTML or other non-JSON
        const text = await response.text()
        console.error('Non-JSON response:', text.slice(0, 500))
        throw new Error('Server returned non-JSON response')
      }

      const data = await response.json()

      if (response.status === 204 || !data.snippet) {
        alert('No preview available for this page.')
      } else {
        setPreviewData(prev => ({ ...prev, [key]: data }))
      }
    } catch (error) {
      console.error('Preview error:', error)
      alert(`Preview unavailable. ${error instanceof Error ? error.message : 'Unknown error'}\nOpening search page instead.`)
      window.open(url, '_blank')
    } finally {
      setLoadingPreview(prev => ({ ...prev, [key]: false }))
    }
  }

  if (resumeListText.length === 0) {
    return (
      <main style={styles.main}>
        <div style={styles.header}>
          <h1 style={styles.mainTitle}>Job Finder - QA/Test Roles</h1>
          <p style={styles.mainSubtitle}>Upload your resume to get started</p>
        </div>
        <ResumeUploader />
      </main>
    )
  }

  return (
    <main style={styles.main}>
      <div style={styles.header}>
        <h1 style={styles.mainTitle}>Job Finder - QA/Test Roles</h1>
        <p style={styles.mainSubtitle}>
          {resumeListText.length} resume(s) analyzed ‚Ä¢ {roles.length} relevant roles found
        </p>
      </div>

      <ResumeUploader />

      {isAnalyzing && (
        <div style={styles.analyzing}>
          <p>Analyzing resumes...</p>
        </div>
      )}

      {!isAnalyzing && roles.length > 0 && (
        <div style={styles.rolesContainer}>
          <h2 style={styles.rolesTitle}>Recommended Roles</h2>

          <div style={styles.rolesGrid}>
            {roles.map((role, idx) => (
              <RoleCard
                key={idx}
                role={role}
                onPreview={handlePreview}
                previewData={previewData}
                loadingPreview={loadingPreview}
              />
            ))}
          </div>
        </div>
      )}
    </main>
  )
}

interface RoleCardProps {
  role: JobRole
  onPreview: (role: string, portal: string, url: string) => void
  previewData: Record<string, any>
  loadingPreview: Record<string, boolean>
}

function RoleCard({ role, onPreview, previewData, loadingPreview }: RoleCardProps) {
  const portals = [
    { name: 'Naukri', url: role.searchLinks.naukri },
    { name: 'LinkedIn', url: role.searchLinks.linkedin },
    { name: 'Indeed', url: role.searchLinks.indeed },
    { name: 'Glassdoor', url: role.searchLinks.glassdoor },
    { name: 'Monster', url: role.searchLinks.monster },
    { name: 'Adzuna', url: role.searchLinks.adzuna },
    { name: 'Google', url: role.searchLinks.google },
  ]

  return (
    <div style={styles.card}>
      <div style={styles.cardHeader}>
        <h3 style={styles.roleTitle}>{role.role}</h3>
        <div style={styles.scoreBadge}>Score: {role.score}</div>
      </div>

      <p style={styles.reason}>{role.reason}</p>

      <div style={styles.linksSection}>
        <h4 style={styles.linksTitle}>Search on:</h4>
        <div style={styles.linksGrid}>
          {portals.map(portal => {
            const key = `${role.role}-${portal.name}`
            const preview = previewData[key]
            const loading = loadingPreview[key]

            return (
              <div key={portal.name} style={styles.portalItem}>
                <a
                  href={portal.url}
                  target=""_blank""
                  rel=""noopener noreferrer""
                  style={styles.portalLink}
                >
                  {portal.name}
                </a>
                <button
                  onClick={() => onPreview(role.role, portal.name, portal.url)}
                  style={styles.previewButton}
                  disabled={loading}
                >
                  {loading ? '...' : 'üëÅ'}
                </button>

                {preview && (
                  <div style={styles.previewBox}>
                    <strong>Preview:</strong>
                    <p style={styles.previewText}>{preview.snippet}</p>
                    <small>Source: {preview.sourceHost}</small>
                  </div>
                )}
              </div>
            )
          })}
        </div>
      </div>
    </div>
  )
}

const styles: Record<string, React.CSSProperties> = {
  main: {
    maxWidth: '1200px',
    margin: '0 auto',
    padding: '24px',
  },
  header: {
    textAlign: 'center',
    marginBottom: '32px',
  },
  mainTitle: {
    fontSize: '36px',
    color: '#333',
    marginBottom: '8px',
  },
  mainSubtitle: {
    fontSize: '16px',
    color: '#666',
  },
  analyzing: {
    textAlign: 'center',
    padding: '32px',
    fontSize: '18px',
    color: '#666',
  },
  rolesContainer: {
    marginTop: '32px',
  },
  rolesTitle: {
    fontSize: '28px',
    marginBottom: '24px',
    color: '#333',
  },
  rolesGrid: {
    display: 'grid',
    gridTemplateColumns: 'repeat(auto-fill, minmax(350px, 1fr))',
    gap: '24px',
  },
  card: {
    backgroundColor: '#ffffff',
    borderRadius: '8px',
    padding: '20px',
    boxShadow: '0 2px 8px rgba(0,0,0,0.1)',
    transition: 'box-shadow 0.2s',
  },
  cardHeader: {
    display: 'flex',
    justifyContent: 'space-between',
    alignItems: 'flex-start',
    marginBottom: '12px',
  },
  roleTitle: {
    fontSize: '20px',
    color: '#0070f3',
    margin: 0,
    flex: 1,
  },
  scoreBadge: {
    backgroundColor: '#0070f3',
    color: 'white',
    padding: '4px 12px',
    borderRadius: '12px',
    fontSize: '14px',
    fontWeight: '600',
  },
  reason: {
    fontSize: '14px',
    color: '#666',
    marginBottom: '16px',
  },
  linksSection: {
    borderTop: '1px solid #eee',
    paddingTop: '16px',
  },
  linksTitle: {
    fontSize: '14px',
    fontWeight: '600',
    marginBottom: '12px',
    color: '#333',
  },
  linksGrid: {
    display: 'flex',
    flexDirection: 'column',
    gap: '8px',
  },
  portalItem: {
    display: 'flex',
    alignItems: 'center',
    gap: '8px',
    flexWrap: 'wrap',
  },
  portalLink: {
    color: '#0070f3',
    textDecoration: 'none',
    fontSize: '14px',
    fontWeight: '500',
    flex: 1,
    minWidth: '100px',
  },
  previewButton: {
    backgroundColor: '#f0f0f0',
    border: 'none',
    borderRadius: '4px',
    padding: '4px 8px',
    cursor: 'pointer',
    fontSize: '14px',
  },
  previewBox: {
    width: '100%',
    marginTop: '8px',
    padding: '12px',
    backgroundColor: '#f9f9f9',
    borderRadius: '4px',
    fontSize: '13px',
  },
  previewText: {
    margin: '8px 0',
    color: '#333',
  },
}
"
src/contexts/ResumesContext.tsx,2490,"/**
 * ResumesContext - Global state management for resume texts
 * Provides resumeListText array and methods to upload/refresh resumes
 * 
 * No env vars needed here.
 */
'use client'

import React, { createContext, useContext, useState, useCallback } from 'react'

interface ResumesContextType {
  resumeListText: string[]
  setResumeFiles: (files: File[]) => Promise<void>
  refreshFromServer: () => Promise<void>
  isLoading: boolean
  error: string | null
}

const ResumesContext = createContext<ResumesContextType | undefined>(undefined)

export function ResumesProvider({ children }: { children: React.ReactNode }) {
  const [resumeListText, setResumeListText] = useState<string[]>([])
  const [isLoading, setIsLoading] = useState(false)
  const [error, setError] = useState<string | null>(null)

  const setResumeFiles = useCallback(async (files: File[]) => {
    setIsLoading(true)
    setError(null)
    try {
      const formData = new FormData()
      files.forEach(file => formData.append('files', file))

      const response = await fetch('/api/resumes/upload', {
        method: 'POST',
        body: formData,
      })

      if (!response.ok) {
        throw new Error(`Upload failed: ${response.statusText}`)
      }

      const result = await response.json()
      console.log('Upload result:', result)

      // Refresh texts from server
      await refreshFromServer()
    } catch (err) {
      const message = err instanceof Error ? err.message : 'Upload failed'
      setError(message)
      console.error('Upload error:', err)
    } finally {
      setIsLoading(false)
    }
  }, [])

  const refreshFromServer = useCallback(async () => {
    try {
      const response = await fetch('/api/resumes/text')
      if (!response.ok) {
        throw new Error(`Failed to fetch resume texts: ${response.statusText}`)
      }

      const data = await response.json()
      setResumeListText(data.texts || [])
    } catch (err) {
      const message = err instanceof Error ? err.message : 'Failed to load resumes'
      setError(message)
      console.error('Refresh error:', err)
    }
  }, [])

  return (
    <ResumesContext.Provider
      value={{ resumeListText, setResumeFiles, refreshFromServer, isLoading, error }}
    >
      {children}
    </ResumesContext.Provider>
  )
}

export function useResumes() {
  const context = useContext(ResumesContext)
  if (!context) {
    throw new Error('useResumes must be used within ResumesProvider')
  }
  return context
}
"
tests/test-job-finder.js,2760,"/**
 * Simple test script for job-finding logic
 * 
 * Usage: node tests/test-job-finder.js
 * 
 * This test verifies:
 * 1. Resume text extraction produces results
 * 2. At least one target role scores > 30
 * 3. All roles have valid search links
 */

const fs = require('fs')
const path = require('path')

// Mock environment
process.env.USE_LLM_RERANK = 'false'
process.env.DEFAULT_JOB_LOCATION = 'Bangalore'

// Load the job finder (requires build first)
async function runTest() {
  console.log('üß™ Running job-finder tests...\n')

  // Check if resume texts exist
  const resumeTextsPath = path.join(__dirname, '../data/resume_texts.json')

  if (!fs.existsSync(resumeTextsPath)) {
    console.error('‚ùå No resume texts found at data/resume_texts.json')
    console.log('Please upload resumes through the UI first, or run extraction manually.')
    process.exit(1)
  }

  const data = JSON.parse(fs.readFileSync(resumeTextsPath, 'utf-8'))
  const resumeTexts = data.texts || []

  if (resumeTexts.length === 0) {
    console.error('‚ùå No resume texts in data/resume_texts.json')
    process.exit(1)
  }

  console.log(`‚úì Found ${resumeTexts.length} resume text(s)`)
  console.log(`‚úì First resume preview: ${resumeTexts[0].slice(0, 100)}...\n`)

  // Import the job finder (this assumes TypeScript has been compiled)
  // For development, you might need to run this after 'npm run build'
  const { findRelevantJobs } = require('../src/ai/flows/find-relevant-jobs.ts')

  console.log('üîç Finding relevant jobs...\n')

  const result = await findRelevantJobs(resumeTexts)
  const roles = result.roles

  console.log(`‚úì Found ${roles.length} roles total\n`)

  // Check top roles
  const topRoles = roles.slice(0, 5)
  console.log('Top 5 roles:')
  topRoles.forEach((role, idx) => {
    console.log(`  ${idx + 1}. ${role.role} (score: ${role.score})`)
    console.log(`     Reason: ${role.reason}`)
  })
  console.log('')

  // Assertion: at least one role should score > 30
  const highScoreRoles = roles.filter(r => r.score > 30)

  if (highScoreRoles.length === 0) {
    console.error('‚ùå FAIL: No roles scored > 30')
    process.exit(1)
  }

  console.log(`‚úì ${highScoreRoles.length} role(s) scored > 30`)

  // Verify search links
  const firstRole = roles[0]
  const requiredPortals = ['naukri', 'linkedin', 'indeed', 'glassdoor', 'monster', 'adzuna', 'google']
  const missingPortals = requiredPortals.filter(p => !firstRole.searchLinks[p])

  if (missingPortals.length > 0) {
    console.error(`‚ùå FAIL: Missing search links for: ${missingPortals.join(', ')}`)
    process.exit(1)
  }

  console.log('‚úì All search links present')
  console.log('\n‚úÖ All tests passed!')
}

runTest().catch(err => {
  console.error('‚ùå Test error:', err)
  process.exit(1)
})
"
tsconfig.json,601,"{
  ""compilerOptions"": {
    ""target"": ""ES2017"",
    ""lib"": [""dom"", ""dom.iterable"", ""esnext""],
    ""allowJs"": true,
    ""skipLibCheck"": true,
    ""strict"": true,
    ""noEmit"": true,
    ""esModuleInterop"": true,
    ""module"": ""esnext"",
    ""moduleResolution"": ""bundler"",
    ""resolveJsonModule"": true,
    ""isolatedModules"": true,
    ""jsx"": ""preserve"",
    ""incremental"": true,
    ""plugins"": [
      {
        ""name"": ""next""
      }
    ],
    ""paths"": {
      ""@/*"": [""./src/*""]
    }
  },
  ""include"": [""next-env.d.ts"", ""**/*.ts"", ""**/*.tsx"", "".next/types/**/*.ts""],
  ""exclude"": [""node_modules""]
}"
